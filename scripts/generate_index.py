"""Generate an enhanced docs/index.md with grouped commands and short descriptions.

This reads `docs/commands/*.md` (generated by `generate_docs.py`), extracts a
one-line description from each file (from the '## Description' section or the
first paragraph), and writes `docs/index.md` grouped by categories.

Usage:
    python scripts/generate_index.py
"""
from __future__ import annotations

import sys
from pathlib import Path
import re

ROOT = Path(__file__).resolve().parents[1]
CMDS_DIR = ROOT / 'docs' / 'commands'
OUT = ROOT / 'docs' / 'index.md'

# Simple heuristic categories
CATEGORIES = {
    'filesystem': {'ls', 'cat', 'cp', 'mv', 'rm', 'mkdir', 'touch', 'pwd', 'cd'},
    'process': {'htop', 'kill', 'killswitch'},
    'editor': {'nano', 'edit'},
    'core': {'man', 'shell'},
    'misc': {'echo'},
}


def detect_category(name: str) -> str:
    for k, s in CATEGORIES.items():
        if name in s:
            return k
    return 'other'


def extract_description(md_path: Path) -> str:
    text = md_path.read_text(encoding='utf-8')
    # Try to find '## Description' section
    m = re.search(r"## Description\n\n([\s\S]*?)(?:\n\n## |\Z)", text)
    if m:
        desc = m.group(1).strip()
        # take first paragraph line
        first = desc.splitlines()[0].strip()
        # collapse whitespace
        first = ' '.join(first.split())
        return first
    # fallback: take first non-empty line after title
    lines = [ln.strip() for ln in text.splitlines()]
    for i, ln in enumerate(lines):
        if ln.startswith('# '):
            # next non-empty is candidate
            for ln2 in lines[i+1:i+6]:
                if ln2 and not ln2.startswith('##'):
                    return ' '.join(ln2.split())
    return '(no description)'


def generate():
    entries = []
    for p in sorted(CMDS_DIR.iterdir()):
        if not p.name.endswith('.md'):
            continue
        name = p.stem
        desc = extract_description(p)
        cat = detect_category(name)
        entries.append((cat, name, desc))

    # group
    groups = {}
    for cat, name, desc in entries:
        groups.setdefault(cat, []).append((name, desc))

    # canonical order
    order = ['filesystem', 'process', 'editor', 'core', 'misc', 'other']

    out_lines = ['# Wilx Commands', '', 'This index lists available commands grouped by category.\n']
    for cat in order:
        items = groups.get(cat)
        if not items:
            continue
        out_lines.append(f'## {cat.capitalize()}')
        out_lines.append('')
        for name, desc in items:
            out_lines.append(f'- [{name}](commands/{name}.md) â€” {desc}')
        out_lines.append('')

    out_lines.append('You can regenerate the per-command docs with:')
    out_lines.append('')
    out_lines.append('```powershell')
    out_lines.append('python scripts\\generate_docs.py')
    out_lines.append('```')
    out_lines.append('')

    OUT.write_text('\n'.join(out_lines), encoding='utf-8')
    print('Wrote', OUT)
    return 0


if __name__ == '__main__':
    sys.exit(generate())
